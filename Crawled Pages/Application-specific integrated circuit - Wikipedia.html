



Application-specific integrated circuit - Wikipedia
document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );
(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Application-specific_integrated_circuit","wgTitle":"Application-specific integrated circuit","wgCurRevisionId":824021088,"wgRevisionId":824021088,"wgArticleId":147845,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Use dmy dates from January 2011","Articles lacking in-text citations from October 2015","All articles lacking in-text citations","All articles with unsourced statements","Articles with unsourced statements from June 2008","Articles with unsourced statements from August 2017","Wikipedia articles with GND identifiers","Gate arrays","Integrated circuits"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Application-specific_integrated_circuit","wgRelevantArticleId":147845,"wgRequestId":"WoQm8QpAADoAAI@CKfUAAAAP","wgIsProbablyEditable":true,"wgRelevantPageIsProbablyEditable":true,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgRedirectedFrom":"ASIC","wgFlaggedRevsParams":{"tags":{}},"wgStableRevisionId":null,"wgWikiEditorEnabledModules":[],"wgBetaFeaturesFeatures":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgPopupsShouldSendModuleToUser":true,"wgPopupsConflictsWithNavPopupGadget":false,"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en","usePageImages":true,"usePageDescriptions":true},"wgPreferredVariant":"en","wgMFExpandAllSectionsUserOption":false,"wgMFDisplayWikibaseDescriptions":{"search":true,"nearby":true,"watchlist":true,"tagline":false},"wgRelatedArticles":null,"wgRelatedArticlesUseCirrusSearch":true,"wgRelatedArticlesOnlyUseCirrusSearch":false,"wgULSCurrentAutonym":"English","wgNoticeProject":"wikipedia","wgCentralNoticeCookiesToDelete":[],"wgCentralNoticeCategoriesUsingLegacy":["Fundraising","fundraising"],"wgCategoryTreePageCategoryOptions":"{\"mode\":0,\"hideprefix\":20,\"showcount\":true,\"namespaces\":false}","wgInternalRedirectTargetUrl":"/wiki/Application-specific_integrated_circuit","wgWikibaseItemId":"Q217302","wgScoreNoteLanguages":{"arabic":"العربية","catalan":"català","deutsch":"Deutsch","english":"English","espanol":"español","italiano":"italiano","nederlands":"Nederlands","norsk":"norsk","portugues":"português","suomi":"suomi","svenska":"svenska","vlaams":"West-Vlams"},"wgScoreDefaultNoteLanguage":"nederlands","wgCentralAuthMobileDomain":false,"wgCodeMirrorEnabled":false,"wgVisualEditorToolbarScrollOffset":0,"wgVisualEditorUnsupportedEditParams":["undo","undoafter","veswitched"],"wgEditSubmitButtonLabelPublish":true});mw.loader.state({"ext.gadget.charinsert-styles":"ready","ext.globalCssJs.user.styles":"ready","ext.globalCssJs.site.styles":"ready","site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","user.options":"ready","user.tokens":"loading","ext.cite.styles":"ready","wikibase.client.init":"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.uls.interlanguage":"ready","ext.wikimediaBadges":"ready","mediawiki.legacy.shared":"ready","mediawiki.legacy.commonPrint":"ready","mediawiki.sectionAnchor":"ready","mediawiki.skinning.interface":"ready","skins.vector.styles":"ready","ext.globalCssJs.user":"ready","ext.globalCssJs.site":"ready"});mw.loader.implement("user.tokens@1dqfd7l",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
});mw.loader.load(["mediawiki.action.view.redirect","ext.cite.a11y","site","mediawiki.page.startup","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.toc","mediawiki.searchSuggest","ext.gadget.teahouse","ext.gadget.ReferenceTooltips","ext.gadget.watchlist-notice","ext.gadget.DRN-wizard","ext.gadget.charinsert","ext.gadget.refToolbar","ext.gadget.extra-toolbar-buttons","ext.gadget.switcher","ext.centralauth.centralautologin","mmv.head","mmv.bootstrap.autostart","ext.popups","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","ext.eventLogging.subscriber","ext.wikimediaEvents","ext.navigationTiming","ext.uls.eventlogger","ext.uls.init","ext.uls.interface","ext.centralNotice.geoIP","ext.centralNotice.startUp","skins.vector.js"]);});























 





Application-specific integrated circuit 
From Wikipedia, the free encyclopedia   (Redirected from ASIC)

					Jump to:					navigation, 					search

"ASIC" redirects here. For other uses, see ASIC (disambiguation).






This article includes a list of references, related reading or external links, but its sources remain unclear because it lacks inline citations. Please help to improve this article by introducing more precise citations. (October 2015) (Learn how and when to remove this template message)







A tray of application-specific integrated circuit (ASIC) chips


An application-specific integrated circuit (ASIC) /ˈeɪsɪk/, is an integrated circuit (IC) customized for a particular use, rather than intended for general-purpose use. For example, a chip designed to run in a digital voice recorder or a high-efficiency Bitcoin miner is an ASIC. Application-specific standard products (ASSPs) are intermediate between ASICs and industry standard integrated circuits like the 7400 series or the 4000 series.
As feature sizes have shrunk and design tools improved over the years, the maximum complexity (and hence functionality) possible in an ASIC has grown from 5,000 logic gates to over 100 million. Modern ASICs often include entire microprocessors, memory blocks including ROM, RAM, EEPROM, flash memory and other large building blocks. Such an ASIC is often termed a SoC (system-on-chip). Designers of digital ASICs often use a hardware description language (HDL), such as Verilog or VHDL, to describe the functionality of ASICs.
Field-programmable gate arrays (FPGA) are the modern-day technology for building a breadboard or prototype from standard parts; programmable logic blocks and programmable interconnects allow the same FPGA to be used in many different applications. For smaller designs or lower production volumes, FPGAs may be more cost effective than an ASIC design, even in production. The non-recurring engineering (NRE) cost of an ASIC can run into the millions of dollars.



Contents


1 History
2 Standard-cell designs
3 Gate-array and semi-custom design
4 Full-custom design
5 Structured design
6 Cell libraries, IP-based design, hard and soft macros
7 Multi-project wafers
8 Application-specific standard product
9 See also
10 References
11 Sources



History[edit]
The initial ASICs used gate array technology. An early successful commercial application was the gate array circuitry found in the 8-bit ZX81 and ZX Spectrum low-end personal computers, introduced in 1981 and 1982. These were used by Sinclair Research (UK) essentially as a low-cost I/O solution aimed at handling the computer's graphics.
Customization occurred by varying the metal interconnect mask. Gate arrays had complexities of up to a few thousand gates. Later versions became more generalized, with different base dies customised by both metal and polysilicon layers. Some base dies include RAM elements.
Standard-cell designs[edit]
Main article: Standard cell
In the mid-1980s, a designer would choose an ASIC manufacturer and implement their design using the design tools available from the manufacturer. While third-party design tools were available, there was not an effective link from the third-party design tools to the layout and actual semiconductor process performance characteristics of the various ASIC manufacturers. Most designers ended up using factory-specific tools to complete the implementation of their designs. A solution to this problem, which also yielded a much higher density device, was the implementation of standard cells. Every ASIC manufacturer could create functional blocks with known electrical characteristics, such as propagation delay, capacitance and inductance, that could also be represented in third-party tools. Standard-cell design is the utilization of these functional blocks to achieve very high gate density and good electrical performance. Standard-cell design fits between Gate Array and Full Custom design in terms of both its non-recurring engineering and recurring component cost.
By the late 1990s, logic synthesis tools became available. Such tools could compile HDL descriptions into a gate-level netlist. Standard-cell integrated circuits (ICs) are designed in the following conceptual stages, although these stages overlap significantly in practice:

A team of design engineers starts with a non-formal understanding of the required functions for a new ASIC, usually derived from requirements analysis.
The design team constructs a description of an ASIC (application specific integrated circuits) to achieve these goals using an HDL. This process is analogous to writing a computer program in a high-level language. This is usually called the RTL (register-transfer level) design.
Suitability for purpose is verified by functional verification. This may include such techniques as logic simulation, formal verification, emulation, or creating an equivalent pure software model (see Simics, for example). Each technique has advantages and disadvantages, and often several methods are used.
Logic synthesis transforms the RTL design into a large collection of lower-level constructs called standard cells. These constructs are taken from a standard-cell library consisting of pre-characterized collections of gates (such as 2 input nor, 2 input nand, inverters, etc.). The standard cells are typically specific to the planned manufacturer of the ASIC. The resulting collection of standard cells, plus the needed electrical connections between them, is called a gate-level netlist.
The gate-level netlist is next processed by a placement tool which places the standard cells onto a region representing the final ASIC. It attempts to find a placement of the standard cells, subject to a variety of specified constraints.
The routing tool takes the physical placement of the standard cells and uses the netlist to create the electrical connections between them. Since the search space is large, this process will produce a “sufficient” rather than “globally optimal” solution. The output is a file which can be used to create a set of photomasks enabling a semiconductor fabrication facility (commonly called a 'fab') to produce physical ICs.
Given the final layout, circuit extraction computes the parasitic resistances and capacitances. In the case of a digital circuit, this will then be further mapped into delay information, from which the circuit performance can be estimated, usually by static timing analysis. This, and other final tests such as design rule checking and power analysis (collectively called signoff) are intended to ensure that the device will function correctly over all extremes of the process, voltage and temperature. When this testing is complete the photomask information is released for chip fabrication.

These steps, implemented with a level of skill common in the industry, almost always produce a final device that correctly implements the original design, unless flaws are later introduced by the physical fabrication process.
The design steps (or flow) are also common to standard product design. The significant difference is that standard-cell design uses the manufacturer's cell libraries that have been used in potentially hundreds of other design implementations and therefore are of much lower risk than full custom design. Standard cells produce a design density that is cost effective, and they can also integrate IP cores and SRAM (Static Random Access Memory) effectively, unlike Gate Arrays.
Gate-array and semi-custom design[edit]




Microscope photograph of a gate-array ASIC showing the predefined logic cells and custom interconnections. This particular design uses less than 20% of available logic gates.


Gate-array design is a manufacturing method in which the diffused layers, i.e. transistors and other active devices, are predefined and wafers containing such devices are held in stock prior to metallization—in other words, unconnected. The physical design process then defines the interconnections of the final device. For most ASIC manufacturers, this consists of from two to as many as nine metal layers, each metal layer running perpendicular to the one below it. Non-recurring engineering costs are much lower, as photolithographic masks are required only for the metal layers, and production cycles are much shorter, as metallization is a comparatively quick process.
Gate-array ASICs are always a compromise as mapping a given design onto what a manufacturer held as a stock wafer never gives 100% utilization. Often difficulties in routing the interconnect require migration onto a larger array device with consequent increase in the piece part price. These difficulties are often a result of the layout software used to develop the interconnect.
Pure, logic-only gate-array design is rarely implemented by circuit designers today, having been replaced almost entirely by field-programmable devices, such as field-programmable gate arrays (FPGAs), which can be programmed by the user and thus offer minimal tooling charges non-recurring engineering, only marginally increased piece part cost, and comparable performance. Today, gate arrays are evolving into structured ASICs that consist of a large IP core like a CPU, DSP unit, peripherals, standard interfaces, integrated memories SRAM, and a block of reconfigurable, uncommited logic. This shift is largely because ASIC devices are capable of integrating such large blocks of system functionality and "system-on-a-chip" requires far more than just logic blocks.
In their frequent usages in the field, the terms "gate array" and "semi-custom" are synonymous. Process engineers more commonly use the term "semi-custom", while "gate-array" is more commonly used by logic (or gate-level) designers.
Full-custom design[edit]
Main article: Full custom




Microscope photograph of custom ASIC (486 chipset) showing gate-based design on top and custom circuitry on bottom


By contrast, full-custom ASIC design defines all the photolithographic layers of the device. Full-custom design is used for both ASIC design and for standard product design.
The benefits of full-custom design usually include reduced area (and therefore recurring component cost), performance improvements, and also the ability to integrate analog components and other pre-designed — and thus fully verified — components, such as microprocessor cores that form a system-on-chip.
The disadvantages of full-custom design can include increased manufacturing and design time, increased non-recurring engineering costs, more complexity in the computer-aided design (CAD) system, and a much higher skill requirement on the part of the design team.
For digital-only designs, however, "standard-cell" cell libraries, together with modern CAD systems, can offer considerable performance/cost benefits with low risk. Automated layout tools are quick and easy to use and also offer the possibility to "hand-tweak" or manually optimize any performance-limiting aspect of the design.
This is designed by using basic logic gates, circuits or layout specially for a design.
Structured design[edit]
Main article: Structured ASIC platform
Structured ASIC design (also referred to as "platform ASIC design"), is a relatively new term in the industry, resulting in some variation in its definition. However, the basic premise of a structured ASIC is that both manufacturing cycle time and design cycle time are reduced compared to cell-based ASIC, by virtue of there being pre-defined metal layers (thus reducing manufacturing time) and pre-characterization of what is on the silicon (thus reducing design cycle time). One definition states that

In a "structured ASIC" design, the logic mask-layers of a device are predefined by the ASIC vendor (or in some cases by a third party). Design differentiation and customization is achieved by creating custom metal layers that create custom connections between predefined lower-layer logic elements. "Structured ASIC" technology is seen as bridging the gap between field-programmable gate arrays and "standard-cell" ASIC designs. Because only a small number of chip layers must be custom-produced, "structured ASIC" designs have much smaller non-recurring expenditures (NRE) than "standard-cell" or "full-custom" chips, which require that a full mask set be produced for every design.[citation needed]

This is effectively the same definition as a gate array. What makes a structured ASIC different is that in a gate array, the predefined metal layers serve to make manufacturing turnaround faster. In a structured ASIC, the use of predefined metallization is primarily to reduce cost of the mask sets as well as making the design cycle time significantly shorter. For example, in a cell-based or gate-array design the user must often design power, clock, and test structures themselves; these are predefined in most structured ASICs and therefore can save time and expense for the designer compared to gate-array. Likewise, the design tools used for structured ASIC can be substantially lower cost and easier (faster) to use than cell-based tools, because they do not have to perform all the functions that cell-based tools do. In some cases, the structured ASIC vendor requires that customized tools for their device (e.g., custom physical synthesis) be used, also allowing for the design to be brought into manufacturing more quickly.
Cell libraries, IP-based design, hard and soft macros[edit]
Cell libraries of logical primitives are usually provided by the device manufacturer as part of the service. Although they will incur no additional cost, their release will be covered by the terms of a non-disclosure agreement (NDA) and they will be regarded as intellectual property by the manufacturer. Usually their physical design will be pre-defined so they could be termed "hard macros".
What most engineers understand as "intellectual property" are IP cores, designs purchased from a third-party as sub-components of a larger ASIC. They may be provided in the form of a hardware description language (often termed a "soft macro"), or as a fully routed design that could be printed directly onto an ASIC's mask (often termed a hard macro). Many organizations now sell such pre-designed cores — CPUs, Ethernet, USB or telephone interfaces — and larger organizations may have an entire department or division to produce cores for the rest of the organization. Indeed, the wide range of functions now available is a result of the phenomenal improvement in electronics in the late 1990s and early 2000s; as a core takes a lot of time and investment to create, its re-use and further development cuts product cycle times dramatically and creates better products. Additionally, organizations such as OpenCores are collecting free IP cores, paralleling the open-source software movement in hardware design.
Soft macros are often process-independent (i.e. they can be fabricated on a wide range of manufacturing processes and different manufacturers). Hard macros are process-limited and usually further design effort must be invested to migrate (port) to a different process or manufacturer.
Multi-project wafers[edit]
Some manufacturers offer multi-project wafers (MPW) as a method of obtaining low cost prototypes. Often called shuttles, these MPW, containing several designs, run at regular, scheduled intervals on a "cut and go" basis, usually with very little liability on the part of the manufacturer. The contract involves the assembly and packaging of a handful of devices. The service usually involves the supply of a physical design database (i.e. masking information or pattern generation (PG) tape). The manufacturer is often referred to as a "silicon foundry" due to the low involvement it has in the process.
Application-specific standard product[edit]
An application specific standard product or ASSP is an integrated circuit that implements a specific function that appeals to a wide market. As opposed to ASICs that combine a collection of functions and are designed by or for one customer, ASSPs are available as off-the-shelf components. ASSPs are used in all industries, from automotive to communications.[citation needed] As a general rule, if you can find a design in a data book, then it is probably not an ASIC, but there are some exceptions.
For example, two ICs that might or might not be considered ASICs are a controller chip for a PC and a chip for a modem. Both of these examples are specific to an application (which is typical of an ASIC) but are sold to many different system vendors (which is typical of standard parts). ASICs such as these are sometimes called Application-Specific Standard Products (ASSPs).
Examples of ASSPs are encoding/decoding chip, standalone USB interface chip, etc.
IEEE used to publish an ASSP magazine,[1] which was renamed to IEEE Signal Processing Magazine in 1990.
See also[edit]

Application-specific instruction-set processor (ASIP)
Complex programmable logic device (CPLD)
Electronic design automation (EDA or ECAD)
Field-programmable gate array (FPGA)
Multi-project chip (MPC)
Very-large-scale integration (VLSI)
System-on-a-chip (SoC)

References[edit]

Smith, Michael John Sebastian (1997). Application-Specific Integrated Circuits. Addison-Wesley Professional. ISBN 9780201500226. 




^ IEEE ASSP Issue 2, Part 1 -April 1984



Sources[edit]

Barr, Keith (2007). ASIC Design in the Silicon Sandbox: A Complete Guide to Building Mixed-Signal Integrated Circuits. McGraw Hill Professional. ISBN 9780071481618. 
Anthony Cataldo (26 March 2002). "Xilinx looks to ease path to custom FPGAs". EE Times. CMP Media, LLC. 
"Xilinx intros next-gen EasyPath FPGAs priced below structured ASICs". EDP Weekly's IT Monitor. Millin Publishing, Inc. 18 October 2004. 
Golshan, K. (2007). Physical design essentials: an ASIC design implementation perspective. New York: Springer. ISBN 0-387-36642-3.







v
t
e


CPU technologies



Architecture



Turing machine
Post–Turing machine
Universal Turing machine
Quantum Turing machine
Belt machine
Stack machine
Register machine
Counter machine
Pointer machine
Random access machine
Random access stored program machine
Finite-state machine
Queue automaton
Von Neumann
Harvard (modified)
Dataflow
TTA
Cellular
Artificial neural network

Machine learning
Deep learning
Neural processing unit (NPU)


Convolutional neural network
Load/store architecture
Register memory architecture
Endianness
FIFO
Zero-copy
NUMA
HUMA
HSA
Mobile computing
Surface computing
Wearable computing
Heterogeneous computing
Parallel computing
Concurrent computing
Distributed computing
Cloud computing
Amorphous computing
Ubiquitous computing
Fabric computing
Reconfigurable computing
Cognitive computing
Analogous computing
Mechanical computing
Hybrid computing
Digital computing
DNA computing
Peptide computing
Chemical computing
Organic computing
Wetware computing
Quantum computing
Neuromorphic computing
Optical computing
Reversible computing
Unconventional computing
Hypercomputation
Ternary computer
Symmetric multiprocessing (SMP)
Asymmetric multiprocessing (AMP)
Cache hierarchy
Memory hierarchy





ISA types



ASIP
CISC
RISC
EDGE (TRIPS)
VLIW (EPIC)
MISC
OISC
NISC
ZISC
Comparison





ISAs



x86
z/Architecture
ARM
MIPS
Power Architecture (PowerPC)
SPARC
Mill
Itanium (IA-64)
Alpha
Prism
SuperH
V850
Clipper
VAX
Unicore
PA-RISC
MicroBlaze
RISC-V





Word size



1-bit
2-bit
4-bit
8-bit
9-bit
10-bit
12-bit
15-bit
16-bit
18-bit
22-bit
24-bit
25-bit
26-bit
27-bit
31-bit
32-bit
33-bit
34-bit
36-bit
39-bit
40-bit
48-bit
50-bit
60-bit
64-bit
128-bit
256-bit
512-bit
Variable





Execution



Instruction pipelining

Bubble
Operand forwarding


Out-of-order execution

Register renaming


Speculative execution

Branch predictor
Memory dependence prediction


Hazards





Parallel level



Bit

Bit-serial
Word


Instruction
Pipelining

Scalar
Superscalar


Task

Thread
Process


Data

Vector


Memory





Multithreading



Temporal
Simultaneous (SMT) (Hyper-threading)
Speculative (SpMT)
Preemptive
Cooperative
Clustered Multi-Thread (CMT)
Hardware scout





Flynn's taxonomy



SISD
SIMD (SWAR)
SIMT
MISD
MIMD

SPMD


Addressing mode





CPU performance



Instructions per second (IPS)
Instructions per clock (IPC)
Cycles per instruction (CPI)
Floating-point operations per second (FLOPS)
Transactions per second (TPS)
Synaptic Updates Per Second (SUPS)
Performance per watt
Orders of magnitude (computing)
Cache performance measurement and metric





Core count



Single-core processor
Multi-core processor
Manycore processor





Types



Central processing unit (CPU)
GPGPU
AI accelerator
Vision processing unit (VPU)
Vector processor
Barrel processor
Stream processor
Digital signal processor (DSP)
I/O processor/DMA controller
Network processor
Baseband processor
Physics processing unit (PPU)
Coprocessor
Secure cryptoprocessor
ASIC
FPGA
FPOA
CPLD
Microcontroller
Microprocessor
Mobile processor
Notebook processor
Ultra-low-voltage processor
Multi-core processor
Manycore processor
Tile processor
Multi-chip module (MCM)
Chip stack multi-chip modules
System on a chip (SoC)
Multiprocessor system-on-chip (MPSoC)
Programmable System-on-Chip (PSoC)
Network on a chip (NoC)





Components



Execution unit (EU)
Arithmetic logic unit (ALU)
Address generation unit (AGU)
Floating-point unit (FPU)
Load-store unit (LSU)
Branch predictor
Unified Reservation Station
Barrel shifter
Uncore
Sum addressed decoder (SAD)
Front-side bus
Back-side bus
Northbridge (computing)
Southbridge (computing)
Adder (electronics)
Binary multiplier
Binary decoder
Address decoder
Multiplexer
Demultiplexer
Registers
Cache
Memory management unit (MMU)
Input–output memory management unit (IOMMU)
Integrated Memory Controller (IMC)
Power Management Unit (PMU)
Translation lookaside buffer (TLB)
Stack engine
Register file
Processor register
Hardware register
Memory buffer register (MBR)
Program counter
Microcode ROM
Datapath
Control unit
Instruction unit
Re-order buffer
Data buffer
Write buffer
Coprocessor
Electronic switch
Electronic circuit
Integrated circuit
Three-dimensional integrated circuit
Boolean circuit
Digital circuit
Analog circuit
Mixed-signal integrated circuit
Power management integrated circuit
Quantum circuit
Logic gate

Combinational logic
Sequential logic
Emitter-coupled logic (ECL)
Transistor–transistor logic (TTL)
Glue logic


Quantum gate
Gate array
Counter (digital)
Bus (computing)
Semiconductor device
Clock rate
CPU multiplier
Vision chip
Memristor





Power
management



APM
ACPI
Dynamic frequency scaling
Dynamic voltage scaling
Clock gating





Hardware
security



Non-executable memory (NX bit)
Memory Protection Extensions (Intel MPX)
Intel Secure Key
Hardware restriction (firmware)
Software Guard Extensions (Intel SGX)
Trusted Execution Technology
Trusted Platform Module (TPM)
Secure cryptoprocessor
Hardware security module
Hengzhi chip





Related



History of general-purpose CPUs












v
t
e


Programmable logic



Concepts



ASIC
SOC
FPGA

Logic block


CPLD
EPLD
PLA
PAL
GAL
PSoC
Reconfigurable computing

Xputer


Soft microprocessor
Circuit underutilization





Languages



Verilog

A
AMS


VHDL

AMS
VITAL


SystemVerilog

DPI


SystemC
AHDL
Handel-C
PSL
UPF
PALASM
ABEL
CUPL
OpenVera
C to HDL
Flow to HDL
MyHDL
JHDL
ELLA





Companies



Accellera
Actel
Achronix
AMD
Aldec
Altera
Atmel
Cadence
Cypress
Duolog
Forte
Intel
Lattice
National
Mentor Graphics
Microsemi
Signetics
Synopsys

Magma
Virage Logic


Texas Instruments
Tabula
Xilinx





Products




Hardware



iCE
Stratix
Virtex





Software



Altera Quartus
Xilinx ISE
Xilinx Vivado
ModelSim
VTR
Simulators





IP




Proprietary



ARC
LEON
LatticeMico8
MicroBlaze
PicoBlaze
Nios
Nios II





Open-source



JOP
LatticeMico32
OpenCores
OpenRISC

1200


RISC-V
Zet















Authority control



GND: 4122250-7










 
						Retrieved from "https://en.wikipedia.org/w/index.php?title=Application-specific_integrated_circuit&oldid=824021088"					
Categories: Gate arraysIntegrated circuitsHidden categories: Use dmy dates from January 2011Articles lacking in-text citations from October 2015All articles lacking in-text citationsAll articles with unsourced statementsArticles with unsourced statements from June 2008Articles with unsourced statements from August 2017Wikipedia articles with GND identifiers 



Navigation menu


Personal tools

Not logged inTalkContributionsCreate accountLog in 



Namespaces

ArticleTalk 



Variants









Views

ReadEditView history 


More







Search



 







Navigation


Main pageContentsFeatured contentCurrent eventsRandom articleDonate to WikipediaWikipedia store 



Interaction


HelpAbout WikipediaCommunity portalRecent changesContact page 



Tools


What links hereRelated changesUpload fileSpecial pagesPermanent linkPage informationWikidata itemCite this page 



Print/export


Create a bookDownload as PDFPrintable version 



Languages


CatalàČeštinaDanskDeutschEspañolفارسیFrançais한국어हिन्दीBahasa IndonesiaItalianoעבריתLietuviųMagyarNederlands日本語Norsk nynorskPolskiPortuguêsRomânăРусскийSimple EnglishSlovenčinaСрпски / srpskiSuomiSvenskaTürkçeУкраїнськаTiếng Việt中文 
Edit links 





 This page was last edited on 4 February 2018, at 21:14.
Text is available under the Creative Commons Attribution-ShareAlike License;
additional terms may apply.  By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.


Privacy policy
About Wikipedia
Disclaimers
Contact Wikipedia
Developers
Cookie statement
Mobile view



 

 



(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.260","walltime":"0.380","ppvisitednodes":{"value":1275,"limit":1000000},"ppgeneratednodes":{"value":0,"limit":1500000},"postexpandincludesize":{"value":83550,"limit":2097152},"templateargumentsize":{"value":1683,"limit":2097152},"expansiondepth":{"value":15,"limit":40},"expensivefunctioncount":{"value":5,"limit":500},"entityaccesscount":{"value":1,"limit":400},"timingprofile":["100.00%  268.741      1 -total"," 17.11%   45.982      1 Template:No_footnotes"," 16.10%   43.263      2 Template:Cite_book"," 14.32%   38.488      2 Template:Citation_needed"," 13.26%   35.644      1 Template:Ambox"," 12.89%   34.639      2 Template:Fix"," 10.49%   28.184      1 Template:Redirect","  8.28%   22.241      4 Template:Navbox","  8.18%   21.990      1 Template:Authority_control","  7.16%   19.249      2 Template:Delink"]},"scribunto":{"limitreport-timeusage":{"value":"0.108","limit":"10.000"},"limitreport-memusage":{"value":4361759,"limit":52428800}},"cachereport":{"origin":"mw1249","timestamp":"20180213202856","ttl":1900800,"transientcontent":false}}});});(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":105,"wgHostname":"mw1263"});});


